---
alwaysApply: true
---

# Next.js Data Patterns & Server Actions

This project follows strict patterns for data handling in Next.js 15 using App Router.

## Core Principles

1. **Data Retrieval**: Always use Server Components
2. **Data Mutations**: Always use Server Actions
3. **Data Validation**: Always use Zod schemas
4. **Type Safety**: All server action inputs must have TypeScript types (NO FormData type)

## Data Retrieval Pattern

### ✅ CORRECT: Server Component Data Fetching

```typescript
// app/dashboard/page.tsx
import { auth } from '@clerk/nextjs/server';
import { db } from '@/db/index';
import { decksTable } from '@/db/schema';
import { eq, desc } from 'drizzle-orm';

export default async function DashboardPage() {
  const { userId } = await auth();
  
  if (!userId) {
    redirect('/sign-in');
  }
  
  // ✅ Fetch data directly in server component
  const decks = await db.select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId))
    .orderBy(desc(decksTable.createdAt));
  
  return (
    <div>
      {decks.map(deck => (
        <DeckCard key={deck.id} deck={deck} />
      ))}
    </div>
  );
}
```

### ❌ WRONG: Using API Routes for Data Fetching

```typescript
// ❌ Don't create API routes just to fetch data
// app/api/decks/route.ts
export async function GET() {
  // This is unnecessary - fetch directly in server components
}

// ❌ Don't use useEffect to fetch data
'use client';
export function MyComponent() {
  useEffect(() => {
    fetch('/api/decks').then(/* ... */);
  }, []);
}
```

## Data Mutation Pattern

### Step 1: Define Zod Schema

```typescript
// lib/validations/deck.ts
import { z } from 'zod';

export const createDeckSchema = z.object({
  name: z.string().min(1, 'Name is required').max(255, 'Name too long'),
  description: z.string().max(1000, 'Description too long').optional(),
});

export const updateDeckSchema = z.object({
  id: z.number().int().positive(),
  name: z.string().min(1, 'Name is required').max(255, 'Name too long'),
  description: z.string().max(1000, 'Description too long').optional(),
});

export const deleteDeckSchema = z.object({
  id: z.number().int().positive(),
});

// Export TypeScript types from Zod schemas
export type CreateDeckInput = z.infer<typeof createDeckSchema>;
export type UpdateDeckInput = z.infer<typeof updateDeckSchema>;
export type DeleteDeckInput = z.infer<typeof deleteDeckSchema>;
```

### Step 2: Create Server Action

```typescript
// app/actions/deck-actions.ts
'use server';

import { auth } from '@clerk/nextjs/server';
import { db } from '@/db/index';
import { decksTable } from '@/db/schema';
import { eq, and } from 'drizzle-orm';
import { revalidatePath } from 'next/cache';
import { 
  createDeckSchema, 
  updateDeckSchema, 
  deleteDeckSchema,
  type CreateDeckInput,
  type UpdateDeckInput,
  type DeleteDeckInput
} from '@/lib/validations/deck';

export async function createDeck(input: CreateDeckInput) {
  // 1. Validate input with Zod
  const validated = createDeckSchema.parse(input);
  
  // 2. Check authentication
  const { userId } = await auth();
  if (!userId) {
    throw new Error('Unauthorized');
  }
  
  // 3. Perform database operation
  const [newDeck] = await db.insert(decksTable).values({
    userId,
    name: validated.name,
    description: validated.description || '',
  }).returning();
  
  // 4. Revalidate affected paths
  revalidatePath('/dashboard');
  
  return { success: true, data: newDeck };
}

export async function updateDeck(input: UpdateDeckInput) {
  // 1. Validate input
  const validated = updateDeckSchema.parse(input);
  
  // 2. Check authentication
  const { userId } = await auth();
  if (!userId) {
    throw new Error('Unauthorized');
  }
  
  // 3. Update with ownership check
  const [updated] = await db.update(decksTable)
    .set({
      name: validated.name,
      description: validated.description,
      updatedAt: new Date(),
    })
    .where(and(
      eq(decksTable.id, validated.id),
      eq(decksTable.userId, userId)
    ))
    .returning();
  
  if (!updated) {
    throw new Error('Deck not found or access denied');
  }
  
  // 4. Revalidate
  revalidatePath('/dashboard');
  revalidatePath(`/deck/${validated.id}`);
  
  return { success: true, data: updated };
}

export async function deleteDeck(input: DeleteDeckInput) {
  // 1. Validate input
  const validated = deleteDeckSchema.parse(input);
  
  // 2. Check authentication
  const { userId } = await auth();
  if (!userId) {
    throw new Error('Unauthorized');
  }
  
  // 3. Delete with ownership check
  const [deleted] = await db.delete(decksTable)
    .where(and(
      eq(decksTable.id, validated.id),
      eq(decksTable.userId, userId)
    ))
    .returning();
  
  if (!deleted) {
    throw new Error('Deck not found or access denied');
  }
  
  // 4. Revalidate
  revalidatePath('/dashboard');
  
  return { success: true };
}
```

### Step 3: Call Server Action from Client Component

```typescript
// components/create-deck-form.tsx
'use client';

import { useState } from 'react';
import { createDeck } from '@/app/actions/deck-actions';
import type { CreateDeckInput } from '@/lib/validations/deck';

export function CreateDeckForm() {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  async function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    setIsLoading(true);
    setError(null);
    
    const formData = new FormData(e.currentTarget);
    
    // ✅ Create properly typed input object
    const input: CreateDeckInput = {
      name: formData.get('name') as string,
      description: formData.get('description') as string,
    };
    
    try {
      // ✅ Call server action with typed input
      const result = await createDeck(input);
      
      if (result.success) {
        // Handle success (close modal, show toast, etc.)
        e.currentTarget.reset();
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setIsLoading(false);
    }
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <input type="text" name="name" required />
      <textarea name="description" />
      <button type="submit" disabled={isLoading}>
        {isLoading ? 'Creating...' : 'Create Deck'}
      </button>
      {error && <p className="error">{error}</p>}
    </form>
  );
}
```

## Server Action Rules

### ✅ DO

1. **Mark files with 'use server'** directive at the top
2. **Validate all inputs** with Zod schemas
3. **Use TypeScript types** derived from Zod schemas
4. **Check authentication** with `await auth()`
5. **Verify ownership** for updates/deletes
6. **Use revalidatePath()** to update cached data
7. **Return structured responses** with `{ success: true, data?: ... }` or throw errors
8. **Handle errors** appropriately

### ❌ DON'T

1. **Don't use FormData as the type** for server action parameters
   ```typescript
   // ❌ WRONG
   export async function createDeck(formData: FormData) { }
   
   // ✅ CORRECT
   export async function createDeck(input: CreateDeckInput) { }
   ```

2. **Don't skip validation**
   ```typescript
   // ❌ WRONG
   export async function createDeck(input: any) {
     await db.insert(decksTable).values(input);
   }
   
   // ✅ CORRECT
   export async function createDeck(input: CreateDeckInput) {
     const validated = createDeckSchema.parse(input);
     await db.insert(decksTable).values(validated);
   }
   ```

3. **Don't use API routes for mutations** (use server actions instead)
4. **Don't accept unvalidated input** from clients
5. **Don't forget to revalidate** affected paths

## File Organization

```
src/
├── app/
│   ├── actions/
│   │   ├── deck-actions.ts      # Server actions for decks
│   │   └── card-actions.ts      # Server actions for cards
│   ├── dashboard/
│   │   └── page.tsx             # Server component (data fetching)
│   └── deck/
│       └── [id]/
│           └── page.tsx         # Server component (data fetching)
├── components/
│   ├── create-deck-form.tsx     # Client component (calls server actions)
│   └── deck-card.tsx            # Client component (calls server actions)
└── lib/
    └── validations/
        ├── deck.ts              # Zod schemas for deck operations
        └── card.ts              # Zod schemas for card operations
```

## Validation Patterns

### Basic Schema

```typescript
import { z } from 'zod';

export const mySchema = z.object({
  field1: z.string().min(1),
  field2: z.number().positive(),
  field3: z.string().email().optional(),
});

export type MyInput = z.infer<typeof mySchema>;
```

### Nested Schema

```typescript
export const createDeckWithCardsSchema = z.object({
  name: z.string().min(1).max(255),
  description: z.string().max(1000).optional(),
  cards: z.array(z.object({
    front: z.string().min(1),
    back: z.string().min(1),
  })).min(1, 'At least one card is required'),
});

export type CreateDeckWithCardsInput = z.infer<typeof createDeckWithCardsSchema>;
```

### Refined Schema (Custom Validation)

```typescript
export const updateCardSchema = z.object({
  id: z.number().int().positive(),
  deckId: z.number().int().positive(),
  front: z.string().min(1),
  back: z.string().min(1),
}).refine(data => data.front !== data.back, {
  message: "Front and back cannot be identical",
  path: ["back"],
});
```

## Error Handling in Server Actions

```typescript
'use server';

import { z } from 'zod';

export async function myAction(input: MyInput) {
  try {
    // Validate - will throw ZodError if invalid
    const validated = mySchema.parse(input);
    
    // Auth check
    const { userId } = await auth();
    if (!userId) {
      throw new Error('Unauthorized');
    }
    
    // Database operation
    const result = await db.insert(table).values(validated).returning();
    
    revalidatePath('/path');
    
    return { success: true, data: result };
  } catch (error) {
    if (error instanceof z.ZodError) {
      // Return validation errors
      return { 
        success: false, 
        error: 'Validation failed', 
        issues: error.issues 
      };
    }
    
    // Return generic error
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Unknown error' 
    };
  }
}
```

## Best Practices Summary

1. **Server Components**: Fetch data directly, no API routes needed
2. **Server Actions**: All mutations go through validated server actions
3. **Zod Validation**: Every server action validates input with Zod
4. **Type Safety**: Use `z.infer<typeof schema>` for TypeScript types
5. **NO FormData**: Always use typed objects, not FormData
6. **Authentication**: Always check `userId` in server actions
7. **Authorization**: Verify ownership before mutations
8. **Revalidation**: Call `revalidatePath()` after mutations
9. **Error Handling**: Catch and handle Zod and database errors
10. **File Organization**: Keep actions, validations, and components organized

## Integration with Other Rules

This pattern works alongside:
- [clerk-auth-security.mdc](mdc:.cursor/rules/clerk-auth-security.mdc) - Authentication and authorization
- [drizzle-database.mdc](mdc:.cursor/rules/drizzle-database.mdc) - Database queries
- Both patterns must be combined in every server action
