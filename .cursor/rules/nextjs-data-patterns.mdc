---
alwaysApply: true
---
# Next.js Data Patterns & Server Actions

This project follows strict patterns for data handling in Next.js 15 using App Router.

## Core Principles

1. **Data Retrieval**: Always use Server Components with query helper functions
2. **Data Mutations**: Always use Server Actions with query helper functions
3. **Data Validation**: Always use Zod schemas
4. **Type Safety**: All server action inputs must have TypeScript types (NO FormData type)
5. **Database Abstraction**: ALL database operations MUST go through query helper functions in `db/queries/`

## Data Retrieval Pattern

### Step 1: Create Query Helper Function

```typescript
// db/queries/deck-queries.ts
import { db } from '@/db/index';
import { decksTable, cardsTable } from '@/db/schema';
import { eq, desc, asc, and } from 'drizzle-orm';

export async function getUserDecks(userId: string) {
  return await db.select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId))
    .orderBy(desc(decksTable.createdAt));
}

export async function getDeckById(deckId: number, userId: string) {
  const [deck] = await db.select()
    .from(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));
  
  return deck;
}

export async function getDeckWithCards(deckId: number, userId: string) {
  const deck = await getDeckById(deckId, userId);
  
  if (!deck) {
    return null;
  }
  
  const cards = await db.select()
    .from(cardsTable)
    .where(eq(cardsTable.deckId, deckId))
    .orderBy(asc(cardsTable.createdAt));
  
  return { ...deck, cards };
}
```

### Step 2: Use Query Function in Server Component

```typescript
// app/dashboard/page.tsx
import { auth } from '@clerk/nextjs/server';
import { redirect } from 'next/navigation';
import { getUserDecks } from '@/db/queries/deck-queries';

export default async function DashboardPage() {
  const { userId } = await auth();
  
  if (!userId) {
    redirect('/sign-in');
  }
  
  // ✅ Fetch data using query helper function
  const decks = await getUserDecks(userId);
  
  return (
    <div>
      {decks.map(deck => (
        <DeckCard key={deck.id} deck={deck} />
      ))}
    </div>
  );
}
```

### ❌ WRONG: Direct Database Queries or API Routes

```typescript
// ❌ Don't query database directly in server components
// app/dashboard/page.tsx
import { db } from '@/db/index';
import { decksTable } from '@/db/schema';

export default async function DashboardPage() {
  // ❌ WRONG: Direct database query
  const decks = await db.select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
  
  // ...
}

// ❌ Don't create API routes just to fetch data
// app/api/decks/route.ts
export async function GET() {
  // This is unnecessary - use query functions in server components
}

// ❌ Don't use useEffect to fetch data
'use client';
export function MyComponent() {
  useEffect(() => {
    fetch('/api/decks').then(/* ... */);
  }, []);
}
```

## Data Mutation Pattern

### Step 1: Define Zod Schema

```typescript
// lib/validations/deck.ts
import { z } from 'zod';

export const createDeckSchema = z.object({
  name: z.string().min(1, 'Name is required').max(255, 'Name too long'),
  description: z.string().max(1000, 'Description too long').optional(),
});

export const updateDeckSchema = z.object({
  id: z.number().int().positive(),
  name: z.string().min(1, 'Name is required').max(255, 'Name too long'),
  description: z.string().max(1000, 'Description too long').optional(),
});

export const deleteDeckSchema = z.object({
  id: z.number().int().positive(),
});

// Export TypeScript types from Zod schemas
export type CreateDeckInput = z.infer<typeof createDeckSchema>;
export type UpdateDeckInput = z.infer<typeof updateDeckSchema>;
export type DeleteDeckInput = z.infer<typeof deleteDeckSchema>;
```

### Step 2: Create Mutation Helper Functions

```typescript
// db/queries/deck-queries.ts (continued from above)
import { db } from '@/db/index';
import { decksTable, cardsTable } from '@/db/schema';
import { eq, and } from 'drizzle-orm';

// ... read queries from above ...

export async function insertDeck(data: {
  userId: string;
  name: string;
  description: string;
}) {
  const [newDeck] = await db.insert(decksTable)
    .values(data)
    .returning();
  
  return newDeck;
}

export async function updateDeckById(
  deckId: number,
  userId: string,
  data: {
    name?: string;
    description?: string;
  }
) {
  const [updated] = await db.update(decksTable)
    .set({
      ...data,
      updatedAt: new Date(),
    })
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
    .returning();
  
  return updated;
}

export async function deleteDeckById(deckId: number, userId: string) {
  const [deleted] = await db.delete(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
    .returning();
  
  return deleted;
}
```

### Step 3: Create Server Action

```typescript
// app/actions/deck-actions.ts
'use server';

import { auth } from '@clerk/nextjs/server';
import { revalidatePath } from 'next/cache';
import { 
  createDeckSchema, 
  updateDeckSchema, 
  deleteDeckSchema,
  type CreateDeckInput,
  type UpdateDeckInput,
  type DeleteDeckInput
} from '@/lib/validations/deck';
import {
  insertDeck,
  updateDeckById,
  deleteDeckById,
} from '@/db/queries/deck-queries';

export async function createDeck(input: CreateDeckInput) {
  // 1. Validate input with Zod
  const validated = createDeckSchema.parse(input);
  
  // 2. Check authentication
  const { userId } = await auth();
  if (!userId) {
    throw new Error('Unauthorized');
  }
  
  // 3. Call query helper function
  const newDeck = await insertDeck({
    userId,
    name: validated.name,
    description: validated.description || '',
  });
  
  // 4. Revalidate affected paths
  revalidatePath('/dashboard');
  
  return { success: true, data: newDeck };
}

export async function updateDeck(input: UpdateDeckInput) {
  // 1. Validate input
  const validated = updateDeckSchema.parse(input);
  
  // 2. Check authentication
  const { userId } = await auth();
  if (!userId) {
    throw new Error('Unauthorized');
  }
  
  // 3. Call query helper function with ownership check
  const updated = await updateDeckById(validated.id, userId, {
    name: validated.name,
    description: validated.description,
  });
  
  if (!updated) {
    throw new Error('Deck not found or access denied');
  }
  
  // 4. Revalidate
  revalidatePath('/dashboard');
  revalidatePath(`/deck/${validated.id}`);
  
  return { success: true, data: updated };
}

export async function deleteDeck(input: DeleteDeckInput) {
  // 1. Validate input
  const validated = deleteDeckSchema.parse(input);
  
  // 2. Check authentication
  const { userId } = await auth();
  if (!userId) {
    throw new Error('Unauthorized');
  }
  
  // 3. Call query helper function with ownership check
  const deleted = await deleteDeckById(validated.id, userId);
  
  if (!deleted) {
    throw new Error('Deck not found or access denied');
  }
  
  // 4. Revalidate
  revalidatePath('/dashboard');
  
  return { success: true };
}
```

### Step 4: Call Server Action from Client Component

```typescript
// components/create-deck-form.tsx
'use client';

import { useState } from 'react';
import { createDeck } from '@/app/actions/deck-actions';
import type { CreateDeckInput } from '@/lib/validations/deck';

export function CreateDeckForm() {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  async function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    setIsLoading(true);
    setError(null);
    
    const formData = new FormData(e.currentTarget);
    
    // ✅ Create properly typed input object
    const input: CreateDeckInput = {
      name: formData.get('name') as string,
      description: formData.get('description') as string,
    };
    
    try {
      // ✅ Call server action with typed input
      const result = await createDeck(input);
      
      if (result.success) {
        // Handle success (close modal, show toast, etc.)
        e.currentTarget.reset();
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setIsLoading(false);
    }
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <input type="text" name="name" required />
      <textarea name="description" />
      <button type="submit" disabled={isLoading}>
        {isLoading ? 'Creating...' : 'Create Deck'}
      </button>
      {error && <p className="error">{error}</p>}
    </form>
  );
}
```

## Server Action Rules

### ✅ DO

1. **Mark files with 'use server'** directive at the top
2. **Validate all inputs** with Zod schemas
3. **Use TypeScript types** derived from Zod schemas
4. **Check authentication** with `await auth()`
5. **Verify ownership** for updates/deletes
6. **Use revalidatePath()** to update cached data
7. **Return structured responses** with `{ success: true, data?: ... }` or throw errors
8. **Handle errors** appropriately

### ❌ DON'T

1. **Don't use FormData as the type** for server action parameters
   ```typescript
   // ❌ WRONG
   export async function createDeck(formData: FormData) { }
   
   // ✅ CORRECT
   export async function createDeck(input: CreateDeckInput) { }
   ```

2. **Don't skip validation**
   ```typescript
   // ❌ WRONG
   export async function createDeck(input: any) {
     await insertDeck(input);
   }
   
   // ✅ CORRECT
   export async function createDeck(input: CreateDeckInput) {
     const validated = createDeckSchema.parse(input);
     await insertDeck(validated);
   }
   ```

3. **Don't query the database directly in server actions**
   ```typescript
   // ❌ WRONG
   export async function createDeck(input: CreateDeckInput) {
     await db.insert(decksTable).values(input);
   }
   
   // ✅ CORRECT
   export async function createDeck(input: CreateDeckInput) {
     await insertDeck(input);
   }
   ```

4. **Don't use API routes for mutations** (use server actions instead)
5. **Don't accept unvalidated input** from clients
6. **Don't forget to revalidate** affected paths

## File Organization

```
src/
├── app/
│   ├── actions/
│   │   ├── deck-actions.ts      # Server actions for decks (uses query helpers)
│   │   └── card-actions.ts      # Server actions for cards (uses query helpers)
│   ├── dashboard/
│   │   └── page.tsx             # Server component (uses query helpers)
│   └── deck/
│       └── [id]/
│           └── page.tsx         # Server component (uses query helpers)
├── components/
│   ├── create-deck-form.tsx     # Client component (calls server actions)
│   └── deck-card.tsx            # Client component (calls server actions)
├── db/
│   ├── index.ts                 # Database instance
│   ├── schema.ts                # Drizzle schema definitions
│   └── queries/
│       ├── deck-queries.ts      # ALL deck-related database operations
│       └── card-queries.ts      # ALL card-related database operations
└── lib/
    └── validations/
        ├── deck.ts              # Zod schemas for deck operations
        └── card.ts              # Zod schemas for card operations
```

## Query Organization Rules

1. **One file per entity** - Create separate query files for each main entity (decks, cards, users, etc.)
2. **All database operations in queries** - NEVER use `db` directly outside of `db/queries/`
3. **Group by operation type** - Organize functions as reads, writes, updates, deletes
4. **Descriptive function names** - Use clear names like `getUserDecks`, `insertDeck`, `updateDeckById`
5. **Include ownership checks** - Query functions should handle authorization when needed
6. **Return typed results** - Leverage Drizzle's type inference

## Validation Patterns

### Basic Schema

```typescript
import { z } from 'zod';

export const mySchema = z.object({
  field1: z.string().min(1),
  field2: z.number().positive(),
  field3: z.string().email().optional(),
});

export type MyInput = z.infer<typeof mySchema>;
```

### Nested Schema

```typescript
export const createDeckWithCardsSchema = z.object({
  name: z.string().min(1).max(255),
  description: z.string().max(1000).optional(),
  cards: z.array(z.object({
    front: z.string().min(1),
    back: z.string().min(1),
  })).min(1, 'At least one card is required'),
});

export type CreateDeckWithCardsInput = z.infer<typeof createDeckWithCardsSchema>;
```

### Refined Schema (Custom Validation)

```typescript
export const updateCardSchema = z.object({
  id: z.number().int().positive(),
  deckId: z.number().int().positive(),
  front: z.string().min(1),
  back: z.string().min(1),
}).refine(data => data.front !== data.back, {
  message: "Front and back cannot be identical",
  path: ["back"],
});
```

## Error Handling in Server Actions

```typescript
'use server';

import { z } from 'zod';
import { auth } from '@clerk/nextjs/server';
import { revalidatePath } from 'next/cache';
import { insertMyEntity } from '@/db/queries/my-queries';

export async function myAction(input: MyInput) {
  try {
    // Validate - will throw ZodError if invalid
    const validated = mySchema.parse(input);
    
    // Auth check
    const { userId } = await auth();
    if (!userId) {
      throw new Error('Unauthorized');
    }
    
    // Call query helper function
    const result = await insertMyEntity(validated);
    
    revalidatePath('/path');
    
    return { success: true, data: result };
  } catch (error) {
    if (error instanceof z.ZodError) {
      // Return validation errors
      return { 
        success: false, 
        error: 'Validation failed', 
        issues: error.issues 
      };
    }
    
    // Return generic error
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Unknown error' 
    };
  }
}
```

## Best Practices Summary

1. **Query Helper Functions**: ALL database operations MUST use query helpers from `db/queries/`
2. **Server Components**: Fetch data using query helpers, no API routes needed
3. **Server Actions**: All mutations use query helpers with validation
4. **Zod Validation**: Every server action validates input with Zod
5. **Type Safety**: Use `z.infer<typeof schema>` for TypeScript types
6. **NO FormData**: Always use typed objects, not FormData
7. **NO Direct DB Access**: Never use `db` directly outside of `db/queries/`
8. **Authentication**: Always check `userId` in server actions
9. **Authorization**: Query functions should handle ownership checks
10. **Revalidation**: Call `revalidatePath()` after mutations
11. **Error Handling**: Catch and handle Zod and database errors
12. **File Organization**: Keep queries, actions, validations, and components organized

## Example Query File Structure

```typescript
// db/queries/deck-queries.ts
import { db } from '@/db/index';
import { decksTable, cardsTable } from '@/db/schema';
import { eq, desc, asc, and } from 'drizzle-orm';

// ========================================
// READ QUERIES
// ========================================

export async function getUserDecks(userId: string) {
  return await db.select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId))
    .orderBy(desc(decksTable.createdAt));
}

export async function getDeckById(deckId: number, userId: string) {
  const [deck] = await db.select()
    .from(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));
  
  return deck;
}

export async function getDeckWithCards(deckId: number, userId: string) {
  const deck = await getDeckById(deckId, userId);
  
  if (!deck) {
    return null;
  }
  
  const cards = await db.select()
    .from(cardsTable)
    .where(eq(cardsTable.deckId, deckId))
    .orderBy(asc(cardsTable.createdAt));
  
  return { ...deck, cards };
}

// ========================================
// WRITE QUERIES
// ========================================

export async function insertDeck(data: {
  userId: string;
  name: string;
  description: string;
}) {
  const [newDeck] = await db.insert(decksTable)
    .values(data)
    .returning();
  
  return newDeck;
}

// ========================================
// UPDATE QUERIES
// ========================================

export async function updateDeckById(
  deckId: number,
  userId: string,
  data: {
    name?: string;
    description?: string;
  }
) {
  const [updated] = await db.update(decksTable)
    .set({
      ...data,
      updatedAt: new Date(),
    })
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
    .returning();
  
  return updated;
}

// ========================================
// DELETE QUERIES
// ========================================

export async function deleteDeckById(deckId: number, userId: string) {
  const [deleted] = await db.delete(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
    .returning();
  
  return deleted;
}
```

## Forbidden Practices

### ❌ NEVER Do These Things

1. **NEVER query database directly in server components**
   ```typescript
   // ❌ WRONG - app/dashboard/page.tsx
   import { db } from '@/db/index';
   
   export default async function Page() {
     const decks = await db.select().from(decksTable); // WRONG!
   }
   ```

2. **NEVER query database directly in server actions**
   ```typescript
   // ❌ WRONG - app/actions/deck-actions.ts
   'use server';
   import { db } from '@/db/index';
   
   export async function createDeck(input: CreateDeckInput) {
     await db.insert(decksTable).values(input); // WRONG!
   }
   ```

3. **NEVER import `db` outside of `db/queries/` directory**
   ```typescript
   // ❌ WRONG - anywhere except db/queries/*.ts
   import { db } from '@/db/index'; // WRONG!
   ```

4. **NEVER import Drizzle operators outside of `db/queries/` directory**
   ```typescript
   // ❌ WRONG - app/actions/deck-actions.ts
   import { eq, and } from 'drizzle-orm'; // WRONG!
   ```

5. **NEVER create API routes for data operations**
   ```typescript
   // ❌ WRONG - app/api/decks/route.ts
   export async function GET() {
     // Use server components with query helpers instead
   }
   ```

### ✅ CORRECT Patterns

1. **Server Components → Query Helpers**
   ```typescript
   // ✅ CORRECT - app/dashboard/page.tsx
   import { getUserDecks } from '@/db/queries/deck-queries';
   
   export default async function Page() {
     const decks = await getUserDecks(userId);
   }
   ```

2. **Server Actions → Query Helpers**
   ```typescript
   // ✅ CORRECT - app/actions/deck-actions.ts
   'use server';
   import { insertDeck } from '@/db/queries/deck-queries';
   
   export async function createDeck(input: CreateDeckInput) {
     await insertDeck(input);
   }
   ```

3. **Only Query Files Import DB and Operators**
   ```typescript
   // ✅ CORRECT - db/queries/deck-queries.ts
   import { db } from '@/db/index';
   import { eq, and } from 'drizzle-orm';
   
   export async function getDeckById(id: number) {
     // ...
   }
   ```

## Integration with Other Rules

This pattern works alongside:
- [clerk-auth-security.mdc](mdc:.cursor/rules/clerk-auth-security.mdc) - Authentication and authorization
- [drizzle-database.mdc](mdc:.cursor/rules/drizzle-database.mdc) - Database queries
- Both patterns must be combined in every server action
- ALL Drizzle queries must be wrapped in query helper functions
